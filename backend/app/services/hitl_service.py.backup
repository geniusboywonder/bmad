"""
Human-in-the-Loop (HITL) Service

Comprehensive HITL system with configurable trigger conditions, workflow integration,
and safety measures for agent approval and oversight.
"""

from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID, uuid4
from datetime import datetime, timedelta, timezone
from decimal import Decimal
import asyncio
import structlog
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func

from app.models.hitl import HitlStatus, HitlAction, HitlHistoryEntry, HitlRequest, HitlResponse
from app.models.task import Task, TaskStatus
from app.models.agent import AgentType, AgentStatus
from app.database.models import (
    HitlRequestDB,
    TaskDB,
    ProjectDB,
    HitlAgentApprovalDB,
    AgentBudgetControlDB,
    EmergencyStopDB,
    ResponseApprovalDB
)
from app.services.context_store import ContextStoreService
from app.services.audit_service import AuditService
from app.services.hitl_trigger_manager import HitlTriggerManager, OversightLevel, HitlTriggerCondition
from app.websocket.manager import websocket_manager
from app.websocket.events import WebSocketEvent, EventType
import structlog

logger = structlog.get_logger(__name__)


class HitlService:
    """
    Comprehensive HITL service with configurable trigger conditions and workflow integration.

    Features:
    - Configurable trigger conditions (phase completion, quality thresholds, conflicts)
    - User-configurable oversight levels (High/Medium/Low)
    - Quality threshold monitoring with agent confidence scoring
    - Conflict detection and escalation mechanisms
    - Complete history tracking with audit trail
    - Bulk approval operations for similar items
    - Context-aware approval interfaces with artifact previews
    - HITL request expiration with configurable timeouts
    - Seamless workflow integration for pausing/resuming
    """

    def __init__(self, db: Session):
        self.db = db
        # Lazy import to avoid circular dependency
        self._workflow_engine = None
        self.context_store = ContextStoreService(db)
        self.audit_service = AuditService(db)
        self.trigger_manager = HitlTriggerManager(db)

        # Default configuration
        self.default_oversight_level = OversightLevel.MEDIUM
        self.bulk_approval_batch_size = 10
        self.default_timeout_hours = 24  # Default timeout for HITL requests
        self.trigger_configs = {}  # Store trigger configurations

    @property
    def workflow_engine(self):
        """Lazy-loaded workflow engine to avoid circular imports."""
        if self._workflow_engine is None:
            from app.services.workflow_engine import WorkflowExecutionEngine
            self._workflow_engine = WorkflowExecutionEngine(self.db)
        return self._workflow_engine

    async def check_hitl_triggers(
        self,
        project_id: UUID,
        task_id: UUID,
        agent_type: str,
        trigger_context: Dict[str, Any]
    ) -> Optional[HitlRequest]:
        """
        Check if any HITL trigger conditions are met and create request if needed.

        Args:
            project_id: Project identifier
            task_id: Task identifier
            agent_type: Agent type that triggered the check
            trigger_context: Context data for trigger evaluation

        Returns:
            HitlRequest if trigger condition met, None otherwise
        """
        # Delegate to trigger manager
        return await self.trigger_manager.check_hitl_triggers(
            project_id, task_id, agent_type, trigger_context
        )



    async def _pause_workflow_for_hitl(
        self,
        hitl_request: HitlRequestDB,
        condition: str,
        trigger_context: Dict[str, Any]
    ) -> None:
        """Pause workflow execution for HITL approval."""

        try:
            # Find active workflow executions for this project
            from app.database.models import WorkflowStateDB
            from app.models.workflow_state import WorkflowExecutionState as ExecutionStateEnum

            active_workflows = self.db.query(WorkflowStateDB).filter(
                and_(
                    WorkflowStateDB.project_id == hitl_request.project_id,
                    WorkflowStateDB.status == ExecutionStateEnum.RUNNING.value
                )
            ).all()

            for workflow_state in active_workflows:
                # Check if this workflow contains the task that triggered HITL
                if workflow_state.steps_data:
                    for step_data in workflow_state.steps_data:
                        if step_data.get("task_id") == str(hitl_request.task_id):
                            # Found the workflow, pause it
                            await self.workflow_engine.pause_workflow_execution(
                                workflow_state.execution_id,
                                f"HITL approval required: {condition}"
                            )
                            break

        except Exception as e:
            logger.error("Failed to pause workflow for HITL",
                        hitl_request_id=str(hitl_request.id),
                        error=str(e))

    async def _emit_hitl_request_event(self, hitl_request: HitlRequestDB) -> None:
        """Emit WebSocket event for HITL request creation."""

        event = WebSocketEvent(
            event_type=EventType.HITL_REQUEST_CREATED,
            project_id=hitl_request.project_id,
            data={
                "hitl_request_id": str(hitl_request.id),
                "task_id": str(hitl_request.task_id),
                "question": hitl_request.question,
                "options": hitl_request.options,
                "expires_at": hitl_request.expires_at.isoformat() if hitl_request.expires_at else None
            }
        )

        try:
            await websocket_manager.broadcast_to_project(event, str(hitl_request.project_id))
        except Exception as e:
            logger.error("Failed to emit HITL request event",
                        hitl_request_id=str(hitl_request.id),
                        error=str(e))

    async def process_hitl_response(
        self,
        request_id: UUID,
        action: HitlAction,
        response_content: Optional[str] = None,
        comment: Optional[str] = None,
        user_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Process HITL response with comprehensive validation and workflow resumption."""

        # Get HITL request
        hitl_request = self.db.query(HitlRequestDB).filter(HitlRequestDB.id == request_id).first()
        if not hitl_request:
            raise ValueError(f"HITL request {request_id} not found")

        if hitl_request.status != HitlStatus.PENDING:
            raise ValueError(f"HITL request {request_id} is not pending")

        # Validate response based on action
        self._validate_hitl_response(action, response_content, comment)

        # Update request status
        if action == HitlAction.APPROVE:
            hitl_request.status = HitlStatus.APPROVED
            hitl_request.user_response = "approved"
        elif action == HitlAction.REJECT:
            hitl_request.status = HitlStatus.REJECTED
            hitl_request.user_response = "rejected"
        elif action == HitlAction.AMEND:
            hitl_request.status = HitlStatus.AMENDED
            hitl_request.user_response = "amended"
            hitl_request.amended_content = {"amended_content": response_content, "comment": comment}

        # Update response data
        hitl_request.response_comment = comment
        hitl_request.responded_at = datetime.now(timezone.utc)

        # Add history entry
        history_entry = HitlHistoryEntry(
            timestamp=datetime.now(timezone.utc),
            action=action.value,
            user_id=user_id,
            content={"response_content": response_content} if response_content else None,
            comment=comment
        )

        if not hitl_request.history:
            hitl_request.history = []
        hitl_request.history.append(history_entry.model_dump(mode="json"))

        self.db.commit()
        self.db.refresh(hitl_request)

        # Update task status based on response
        await self._update_task_status_from_hitl_response(hitl_request, action)

        # Resume workflow if needed
        workflow_resumed = await self._resume_workflow_after_hitl_response(hitl_request, action)

        # Emit WebSocket event
        await self._emit_hitl_response_event(hitl_request, action)

        # Log audit event
        await self.audit_service.log_hitl_event(
            hitl_request_id=hitl_request.id,
            event_type=self.audit_service.EventType.HITL_RESPONSE,
            event_source=self.audit_service.EventSource.USER,
            event_data={
                "action": action.value,
                "status": hitl_request.status.value,
                "user_response": hitl_request.user_response,
                "response_comment": comment,
                "amended_content": hitl_request.amended_content,
                "workflow_resumed": workflow_resumed
            },
            project_id=hitl_request.project_id,
            metadata={
                "user_id": user_id,
                "response_timestamp": datetime.now(timezone.utc).isoformat()
            }
        )

        logger.info("HITL response processed",
                   request_id=str(request_id),
                   action=action.value,
                   workflow_resumed=workflow_resumed)

        return {
            "request_id": str(request_id),
            "action": action.value,
            "status": hitl_request.status.value,
            "workflow_resumed": workflow_resumed,
            "message": self._get_hitl_response_message(action, workflow_resumed)
        }

    def _validate_hitl_response(
        self,
        action: HitlAction,
        response_content: Optional[str],
        comment: Optional[str]
    ) -> None:
        """Validate HITL response data."""

        if action == HitlAction.AMEND and not response_content:
            raise ValueError("Response content is required for amend action")

        if not comment or comment.strip() == "":
            raise ValueError("Comment is required for all HITL responses")

    async def _update_task_status_from_hitl_response(
        self,
        hitl_request: HitlRequestDB,
        action: HitlAction
    ) -> None:
        """Update task status based on HITL response."""

        task = self.db.query(TaskDB).filter(TaskDB.id == hitl_request.task_id).first()
        if not task:
            return

        if action == HitlAction.APPROVE:
            task.status = TaskStatus.COMPLETED
        elif action == HitlAction.REJECT:
            task.status = TaskStatus.FAILED
            task.error_message = f"Task rejected via HITL: {hitl_request.response_comment}"
        elif action == HitlAction.AMEND:
            task.status = TaskStatus.COMPLETED
            # Store amended content in task output
            if hitl_request.amended_content:
                task.output = hitl_request.amended_content

        task.updated_at = datetime.now(timezone.utc)
        self.db.commit()

    async def _resume_workflow_after_hitl_response(
        self,
        hitl_request: HitlRequestDB,
        action: HitlAction
    ) -> bool:
        """Resume workflow after HITL response."""

        try:
            # Find paused workflows for this project
            from app.database.models import WorkflowStateDB
            from app.models.workflow_state import WorkflowExecutionState as ExecutionStateEnum

            paused_workflows = self.db.query(WorkflowStateDB).filter(
                and_(
                    WorkflowStateDB.project_id == hitl_request.project_id,
                    WorkflowStateDB.status == ExecutionStateEnum.PAUSED.value
                )
            ).all()

            workflow_resumed = False

            for workflow_state in paused_workflows:
                # Check if this workflow contains the task that was waiting for HITL
                if workflow_state.steps_data:
                    for step_data in workflow_state.steps_data:
                        if step_data.get("task_id") == str(hitl_request.task_id):
                            # Found the workflow, resume it
                            resume_success = await self.workflow_engine.resume_workflow_execution_sync(
                                workflow_state.execution_id
                            )
                            if resume_success:
                                workflow_resumed = True
                                logger.info("Workflow resumed after HITL response",
                                           execution_id=workflow_state.execution_id,
                                           hitl_request_id=str(hitl_request.id),
                                           action=action.value)
                            break

                if workflow_resumed:
                    break

            return workflow_resumed

        except Exception as e:
            logger.error("Failed to resume workflow after HITL response",
                        hitl_request_id=str(hitl_request.id),
                        error=str(e))
            return False

    async def _emit_hitl_response_event(
        self,
        hitl_request: HitlRequestDB,
        action: HitlAction
    ) -> None:
        """Emit WebSocket event for HITL response."""

        event = WebSocketEvent(
            event_type=EventType.HITL_RESPONSE,
            project_id=hitl_request.project_id,
            data={
                "hitl_request_id": str(hitl_request.id),
                "action": action.value,
                "status": hitl_request.status.value,
                "user_response": hitl_request.user_response,
                "amended_content": hitl_request.amended_content
            }
        )

        try:
            await websocket_manager.broadcast_to_project(event, str(hitl_request.project_id))
        except Exception as e:
            logger.error("Failed to emit HITL response event",
                        hitl_request_id=str(hitl_request.id),
                        error=str(e))

    def _get_hitl_response_message(self, action: HitlAction, workflow_resumed: bool) -> str:
        """Get appropriate response message for HITL action."""

        base_message = {
            HitlAction.APPROVE: "Request approved",
            HitlAction.REJECT: "Request rejected",
            HitlAction.AMEND: "Request amended"
        }.get(action, "Response recorded")

        if workflow_resumed:
            return f"{base_message}. Workflow has been resumed."
        else:
            return f"{base_message}. Workflow resumption status unknown."

    async def get_pending_hitl_requests(
        self,
        project_id: Optional[UUID] = None,
        limit: int = 50
    ) -> List[HitlRequest]:
        """Get pending HITL requests with optional project filtering."""

        query = self.db.query(HitlRequestDB).filter(HitlRequestDB.status == HitlStatus.PENDING)

        if project_id:
            query = query.filter(HitlRequestDB.project_id == project_id)

        # Filter out expired requests
        query = query.filter(
            or_(
                HitlRequestDB.expires_at.is_(None),
                HitlRequestDB.expires_at > datetime.now(timezone.utc)
            )
        )

        hitl_requests = query.order_by(HitlRequestDB.created_at.desc()).limit(limit).all()

        return [HitlRequest.from_db(req) for req in hitl_requests]

    async def bulk_approve_requests(
        self,
        request_ids: List[UUID],
        comment: str,
        user_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Bulk approve multiple HITL requests."""

        if len(request_ids) > self.bulk_approval_batch_size:
            raise ValueError(f"Cannot approve more than {self.bulk_approval_batch_size} requests at once")

        approved_count = 0
        failed_count = 0
        errors = []

        for request_id in request_ids:
            try:
                await self.process_hitl_response(
                    request_id,
                    HitlAction.APPROVE,
                    comment=comment,
                    user_id=user_id
                )
                approved_count += 1
            except Exception as e:
                failed_count += 1
                errors.append(f"Request {request_id}: {str(e)}")

        return {
            "approved_count": approved_count,
            "failed_count": failed_count,
            "errors": errors,
            "message": f"Bulk approval completed: {approved_count} approved, {failed_count} failed"
        }

    async def get_hitl_request_context(
        self,
        request_id: UUID
    ) -> Dict[str, Any]:
        """Get full context for HITL request including artifacts and task details."""

        hitl_request = self.db.query(HitlRequestDB).filter(HitlRequestDB.id == request_id).first()
        if not hitl_request:
            raise ValueError(f"HITL request {request_id} not found")

        # Get task details
        task = self.db.query(TaskDB).filter(TaskDB.id == hitl_request.task_id).first()

        # Get relevant context artifacts
        context_artifacts = []
        if task and task.context_ids:
            context_artifacts = self.context_store.get_artifacts_by_ids(
                [UUID(cid) for cid in task.context_ids]
            )

        # Get workflow execution context if available
        workflow_context = await self._get_workflow_context_for_hitl(hitl_request)

        return {
            "hitl_request": HitlRequest.from_db(hitl_request),
            "task": task,
            "context_artifacts": context_artifacts,
            "workflow_context": workflow_context,
            "project_info": await self._get_project_info(hitl_request.project_id)
        }

    async def _get_workflow_context_for_hitl(self, hitl_request: HitlRequestDB) -> Optional[Dict[str, Any]]:
        """Get workflow execution context for HITL request."""

        try:
            # Find workflow executions that contain this task
            from app.database.models import WorkflowStateDB

            workflows = self.db.query(WorkflowStateDB).filter(
                WorkflowStateDB.project_id == hitl_request.project_id
            ).all()

            for workflow in workflows:
                if workflow.steps_data:
                    for step_data in workflow.steps_data:
                        if step_data.get("task_id") == str(hitl_request.task_id):
                            return {
                                "execution_id": workflow.execution_id,
                                "workflow_id": workflow.workflow_id,
                                "current_step": workflow.current_step,
                                "total_steps": workflow.total_steps,
                                "status": workflow.status
                            }

        except Exception as e:
            logger.error("Failed to get workflow context for HITL",
                        hitl_request_id=str(hitl_request.id),
                        error=str(e))

        return None

    async def _get_project_info(self, project_id: UUID) -> Dict[str, Any]:
        """Get project information for HITL context."""

        project = self.db.query(ProjectDB).filter(ProjectDB.id == project_id).first()

        if project:
            return {
                "project_id": str(project.id),
                "name": project.name,
                "description": project.description,
                "status": project.status
            }

        return {"project_id": str(project_id)}

    async def get_hitl_statistics(self, project_id: Optional[UUID] = None) -> Dict[str, Any]:
        """Get HITL statistics for monitoring and analytics."""

        query = self.db.query(HitlRequestDB)

        if project_id:
            query = query.filter(HitlRequestDB.project_id == project_id)

        total_requests = query.count()
        pending_requests = query.filter(HitlRequestDB.status == HitlStatus.PENDING).count()
        approved_requests = query.filter(HitlRequestDB.status == HitlStatus.APPROVED).count()
        rejected_requests = query.filter(HitlRequestDB.status == HitlStatus.REJECTED).count()
        amended_requests = query.filter(HitlRequestDB.status == HitlStatus.AMENDED).count()
        expired_requests = query.filter(HitlRequestDB.status == HitlStatus.EXPIRED).count()

        # Calculate average response time
        avg_response_time = self.db.query(
            func.avg(
                func.extract('epoch', HitlRequestDB.responded_at - HitlRequestDB.created_at)
            )
        ).filter(
            and_(
                HitlRequestDB.responded_at.isnot(None),
                HitlRequestDB.status.in_([HitlStatus.APPROVED, HitlStatus.REJECTED, HitlStatus.AMENDED])
            )
        ).scalar()

        return {
            "total_requests": total_requests,
            "pending_requests": pending_requests,
            "approved_requests": approved_requests,
            "rejected_requests": rejected_requests,
            "amended_requests": amended_requests,
            "expired_requests": expired_requests,
            "approval_rate": (approved_requests / total_requests) if total_requests > 0 else 0,
            "average_response_time_hours": (avg_response_time / 3600) if avg_response_time else None
        }

    def configure_trigger_condition(
        self,
        condition: str,
        enabled: bool,
        config: Optional[Dict[str, Any]] = None
    ) -> None:
        """Configure a HITL trigger condition."""
        # Delegate to trigger manager
        self.trigger_manager.configure_trigger_condition(condition, enabled, config)

    def set_oversight_level(self, project_id: UUID, level: str) -> None:
        """Set oversight level for a project."""

        if level not in [OversightLevel.HIGH, OversightLevel.MEDIUM, OversightLevel.LOW]:
            raise ValueError(f"Invalid oversight level: {level}")

        # Store oversight level in project metadata or separate table
        # For now, we'll use a simple approach
        project = self.db.query(ProjectDB).filter(ProjectDB.id == project_id).first()
        if project:
            if not project.description:
                project.description = ""
            # Store oversight level in description for now
            project.description = f"[OVERSIGHT:{level}] {project.description}"
            self.db.commit()

        logger.info("Oversight level set for project",
                   project_id=str(project_id),
                   level=level)

    def get_oversight_level(self, project_id: UUID) -> str:
        """Get oversight level for a project."""

        project = self.db.query(ProjectDB).filter(ProjectDB.id == project_id).first()
        if project and project.description and "[OVERSIGHT:" in project.description:
            # Extract oversight level from description
            start = project.description.find("[OVERSIGHT:") + 11
            end = project.description.find("]", start)
            if end > start:
                level = project.description[start:end]
                if level in [OversightLevel.HIGH, OversightLevel.MEDIUM, OversightLevel.LOW]:
                    return level

        return self.default_oversight_level

    async def cleanup_expired_requests(self) -> int:
        """Clean up expired HITL requests and return count of cleaned requests."""

        expired_count = self.db.query(HitlRequestDB).filter(
            and_(
                HitlRequestDB.status == HitlStatus.PENDING,
                HitlRequestDB.expires_at <= datetime.now(timezone.utc)
            )
        ).update({
            "status": HitlStatus.EXPIRED,
            "response_comment": "Request expired due to timeout",
            "responded_at": datetime.now(timezone.utc)
        })

        if expired_count > 0:
            self.db.commit()

        logger.info("Cleaned up expired HITL requests", count=expired_count)

        return expired_count

    def _generate_hitl_question(self, trigger_context: Dict[str, Any]) -> str:
        """Generate a HITL question based on trigger context."""
        trigger_type = trigger_context.get("trigger_type", "unknown")

        if trigger_type == "phase_completion":
            return f"Agent has completed phase '{trigger_context.get('phase', 'unknown')}'. Please review and approve."
        elif trigger_type == "quality_threshold":
            return f"Agent confidence score ({trigger_context.get('confidence', 0)}) is below threshold. Please review."
        elif trigger_type == "conflict":
            return f"Agent detected a conflict in '{trigger_context.get('conflict_type', 'unknown')}'. Please resolve."
        else:
            return "Agent requires human approval. Please review the request."

    def _get_hitl_options(self, trigger_context: Dict[str, Any]) -> List[str]:
        """Get HITL response options based on trigger context."""
        trigger_type = trigger_context.get("trigger_type", "unknown")

        if trigger_type == "phase_completion":
            return ["Approve", "Reject", "Amend"]
        elif trigger_type == "quality_threshold":
            return ["Approve with caution", "Reject", "Request revision"]
        elif trigger_type == "conflict":
            return ["Accept first option", "Accept second option", "Provide alternative"]
        else:
            return ["Approve", "Reject", "Amend"]

    # ===== HITL PHASE GATES ENHANCEMENT =====

    async def create_phase_gate_hitl(
        self,
        project_id: UUID,
        phase: str,
        gate_type: str,
        deliverables: List[Dict[str, Any]],
        quality_metrics: Optional[Dict[str, Any]] = None,
        risk_assessment: Optional[Dict[str, Any]] = None
    ) -> HitlRequest:
        """
        Create a HITL request for phase gate validation.

        Args:
            project_id: Project identifier
            phase: SDLC phase (discovery, plan, design, build, validate, launch)
            gate_type: Type of gate (entry, exit, quality, risk)
            deliverables: List of deliverables to review
            quality_metrics: Quality metrics for validation
            risk_assessment: Risk assessment data

        Returns:
            Created HITL request for phase gate
        """
        # Generate comprehensive phase gate question
        question = self._generate_phase_gate_question(phase, gate_type, deliverables)

        # Get appropriate options based on gate type
        options = self._get_phase_gate_options(gate_type)

        # Create HITL request with extended context
        hitl_request = HitlRequestDB(
            project_id=project_id,
            task_id=uuid4(),  # Phase gates don't have specific tasks
            question=question,
            options=options,
            status=HitlStatus.PENDING,
            expires_at=datetime.now(timezone.utc) + timedelta(hours=self.default_timeout_hours)
        )

        # Store phase gate context in amended_content for now
        hitl_request.amended_content = {
            "phase_gate_context": {
                "phase": phase,
                "gate_type": gate_type,
                "deliverables": deliverables,
                "quality_metrics": quality_metrics,
                "risk_assessment": risk_assessment,
                "created_at": datetime.now(timezone.utc).isoformat()
            }
        }

        self.db.add(hitl_request)
        self.db.commit()
        self.db.refresh(hitl_request)

        # Emit WebSocket event for phase gate HITL
        await self._emit_phase_gate_hitl_event(hitl_request, phase, gate_type)

        # Log audit event
        await self.audit_service.log_hitl_event(
            hitl_request_id=hitl_request.id,
            event_type=self.audit_service.EventType.HITL_REQUEST,
            event_source=self.audit_service.EventSource.SYSTEM,
            event_data={
                "phase": phase,
                "gate_type": gate_type,
                "deliverables_count": len(deliverables),
                "quality_check": quality_metrics is not None,
                "risk_check": risk_assessment is not None
            },
            project_id=project_id,
            metadata={
                "phase_gate": True,
                "gate_type": gate_type,
                "phase": phase
            }
        )

        logger.info("Phase gate HITL request created",
                   project_id=str(project_id),
                   phase=phase,
                   gate_type=gate_type,
                   hitl_request_id=str(hitl_request.id))

        return HitlRequest.from_db(hitl_request)

    def _generate_phase_gate_question(self, phase: str, gate_type: str, deliverables: List[Dict[str, Any]]) -> str:
        """Generate comprehensive phase gate HITL question."""
        phase_names = {
            "discovery": "Discovery",
            "plan": "Planning",
            "design": "Design",
            "build": "Build",
            "validate": "Validation",
            "launch": "Launch"
        }

        gate_descriptions = {
            "entry": "entry into",
            "exit": "exit from",
            "quality": "quality validation for",
            "risk": "risk assessment for"
        }

        phase_name = phase_names.get(phase, phase)
        gate_desc = gate_descriptions.get(gate_type, gate_type)

        deliverables_summary = self._summarize_deliverables(deliverables)

        question = f"""
ðŸšª **PHASE GATE VALIDATION REQUIRED**

**Phase:** {phase_name}
**Gate Type:** {gate_desc}
**Deliverables:** {deliverables_summary}

Please review the deliverables and quality metrics for the {phase_name} phase.
Ensure all requirements are met and quality standards are satisfied before approving progression.

**Key Review Points:**
â€¢ All deliverables completed and documented
â€¢ Quality metrics meet acceptable thresholds
â€¢ No critical risks or blockers identified
â€¢ Phase objectives successfully achieved
â€¢ Next phase readiness confirmed

**Decision:** Approve phase progression, request revisions, or escalate for further review.
"""

        return question.strip()

    def _summarize_deliverables(self, deliverables: List[Dict[str, Any]]) -> str:
        """Summarize deliverables for HITL question."""
        if not deliverables:
            return "No deliverables specified"

        summary_parts = []
        for deliverable in deliverables[:5]:  # Limit to first 5 for readability
            name = deliverable.get("name", "Unnamed deliverable")
            status = deliverable.get("status", "Unknown")
            summary_parts.append(f"{name} ({status})")

        if len(deliverables) > 5:
            summary_parts.append(f"... and {len(deliverables) - 5} more")

        return ", ".join(summary_parts)

    def _get_phase_gate_options(self, gate_type: str) -> List[str]:
        """Get appropriate options for phase gate HITL."""
        if gate_type == "entry":
            return [
                "âœ… Approve Entry - Phase requirements satisfied",
                "â³ Conditional Entry - Address minor gaps first",
                "âŒ Deny Entry - Critical requirements missing",
                "ðŸ”„ Request Additional Preparation"
            ]
        elif gate_type == "exit":
            return [
                "âœ… Approve Exit - All objectives achieved",
                "ðŸ”„ Minor Revisions Required",
                "â³ Major Revisions Needed",
                "âŒ Critical Issues - Cannot proceed"
            ]
        elif gate_type == "quality":
            return [
                "âœ… Quality Standards Met",
                "âš ï¸ Quality Concerns - Address before proceeding",
                "ðŸ”„ Quality Improvements Required",
                "âŒ Quality Standards Not Met"
            ]
        elif gate_type == "risk":
            return [
                "âœ… Acceptable Risk Level",
                "âš ï¸ Risk Mitigation Required",
                "ðŸ”„ Risk Assessment Revision Needed",
                "âŒ Unacceptable Risk Level"
            ]
        else:
            return ["âœ… Approve", "ðŸ”„ Request Revisions", "âŒ Reject"]

    async def _emit_phase_gate_hitl_event(
        self,
        hitl_request: HitlRequestDB,
        phase: str,
        gate_type: str
    ) -> None:
        """Emit WebSocket event for phase gate HITL request."""
        event = WebSocketEvent(
            event_type=EventType.HITL_REQUEST_CREATED,
            project_id=hitl_request.project_id,
            data={
                "hitl_request_id": str(hitl_request.id),
                "phase_gate": True,
                "phase": phase,
                "gate_type": gate_type,
                "question": hitl_request.question,
                "options": hitl_request.options,
                "expires_at": hitl_request.expires_at.isoformat() if hitl_request.expires_at else None,
                "context": hitl_request.amended_content
            }
        )

        try:
            await websocket_manager.broadcast_to_project(event, str(hitl_request.project_id))
        except Exception as e:
            logger.error("Failed to emit phase gate HITL event",
                        hitl_request_id=str(hitl_request.id),
                        error=str(e))

    async def validate_phase_gate_requirements(
        self,
        project_id: UUID,
        phase: str,
        gate_type: str
    ) -> Dict[str, Any]:
        """
        Validate all requirements for a phase gate before creating HITL.

        Args:
            project_id: Project identifier
            phase: SDLC phase
            gate_type: Type of gate

        Returns:
            Validation results with readiness assessment
        """
        validation_results = {
            "phase": phase,
            "gate_type": gate_type,
            "ready_for_gate": False,
            "validation_checks": [],
            "blocking_issues": [],
            "recommendations": []
        }

        # Get project tasks and artifacts
        from app.services.orchestrator import OrchestratorService
        orchestrator = OrchestratorService(self.db)

        # Validate phase completion
        phase_validation = orchestrator.validate_phase_completion(project_id, phase)
        validation_results["validation_checks"].append({
            "check": "phase_completion",
            "status": "passed" if phase_validation["is_complete"] else "failed",
            "details": phase_validation
        })

        if not phase_validation["is_complete"]:
            validation_results["blocking_issues"].append("Phase completion requirements not met")
            validation_results["recommendations"].append("Complete all phase tasks before requesting gate approval")

        # Validate deliverables
        deliverables_validation = await self._validate_phase_deliverables(project_id, phase)
        validation_results["validation_checks"].append({
            "check": "deliverables",
            "status": "passed" if deliverables_validation["complete"] else "failed",
            "details": deliverables_validation
        })

        if not deliverables_validation["complete"]:
            validation_results["blocking_issues"].extend(deliverables_validation["missing"])
            validation_results["recommendations"].append("Complete all required deliverables")

        # Validate quality metrics if applicable
        if gate_type in ["quality", "exit"]:
            quality_validation = await self._validate_phase_quality(project_id, phase)
            validation_results["validation_checks"].append({
                "check": "quality_metrics",
                "status": "passed" if quality_validation["passed"] else "failed",
                "details": quality_validation
            })

            if not quality_validation["passed"]:
                validation_results["blocking_issues"].extend(quality_validation["issues"])
                validation_results["recommendations"].extend(quality_validation["recommendations"])

        # Validate risk assessment if applicable
        if gate_type in ["risk", "exit"]:
            risk_validation = await self._validate_phase_risks(project_id, phase)
            validation_results["validation_checks"].append({
                "check": "risk_assessment",
                "status": "passed" if risk_validation["acceptable"] else "failed",
                "details": risk_validation
            })

            if not risk_validation["acceptable"]:
                validation_results["blocking_issues"].extend(risk_validation["high_risks"])
                validation_results["recommendations"].extend(risk_validation["mitigations"])

        # Determine overall readiness
        validation_results["ready_for_gate"] = (
            len(validation_results["blocking_issues"]) == 0 and
            all(check["status"] == "passed" for check in validation_results["validation_checks"])
        )

        logger.info("Phase gate requirements validation completed",
                   project_id=str(project_id),
                   phase=phase,
                   gate_type=gate_type,
                   ready=validation_results["ready_for_gate"],
                   blocking_issues=len(validation_results["blocking_issues"]))

        return validation_results

    async def _validate_phase_deliverables(self, project_id: UUID, phase: str) -> Dict[str, Any]:
        """Validate deliverables for a phase."""
        # Get expected deliverables for phase
        expected_deliverables = self._get_expected_deliverables_for_phase(phase)

        # Get actual artifacts for project
        artifacts = self.context_store.get_artifacts_by_project(project_id)

        # Check completion
        completed_deliverables = []
        missing_deliverables = []

        for expected in expected_deliverables:
            found = False
            for artifact in artifacts:
                if self._matches_deliverable(artifact, expected):
                    completed_deliverables.append(expected)
                    found = True
                    break
            if not found:
                missing_deliverables.append(expected)

        return {
            "complete": len(missing_deliverables) == 0,
            "completed": completed_deliverables,
            "missing": missing_deliverables,
            "completion_rate": len(completed_deliverables) / len(expected_deliverables) if expected_deliverables else 0
        }

    def _get_expected_deliverables_for_phase(self, phase: str) -> List[Dict[str, Any]]:
        """Get expected deliverables for a phase."""
        phase_deliverables = {
            "discovery": [
                {"type": "requirements", "name": "Requirements Document"},
                {"type": "analysis", "name": "User Analysis"},
                {"type": "user_input", "name": "Project Brief"}
            ],
            "plan": [
                {"type": "architecture", "name": "High-level Architecture"},
                {"type": "plan", "name": "Technical Plan"},
                {"type": "requirements", "name": "Detailed Requirements"}
            ],
            "design": [
                {"type": "design", "name": "System Design"},
                {"type": "api", "name": "API Specifications"},
                {"type": "model", "name": "Data Models"}
            ],
            "build": [
                {"type": "source_code", "name": "Source Code"},
                {"type": "test", "name": "Unit Tests"},
                {"type": "documentation", "name": "Code Documentation"}
            ],
            "validate": [
                {"type": "test", "name": "Integration Tests"},
                {"type": "quality", "name": "Quality Report"},
                {"type": "performance", "name": "Performance Tests"}
            ],
            "launch": [
                {"type": "deployment", "name": "Deployment Configuration"},
                {"type": "monitoring", "name": "Monitoring Setup"},
                {"type": "documentation", "name": "Production Documentation"}
            ]
        }

        return phase_deliverables.get(phase, [])

    def _matches_deliverable(self, artifact, expected: Dict[str, Any]) -> bool:
        """Check if artifact matches expected deliverable."""
        return (
            artifact.artifact_type == expected["type"] or
            expected["name"].lower() in artifact.content.get("title", "").lower() or
            expected["name"].lower() in str(artifact.content).lower()
        )

    async def _validate_phase_quality(self, project_id: UUID, phase: str) -> Dict[str, Any]:
        """Validate quality metrics for a phase."""
        # Get quality-related artifacts
        quality_artifacts = self.context_store.get_artifacts_by_project_and_type(project_id, "quality")

        # Define quality thresholds by phase
        quality_thresholds = {
            "discovery": {"min_score": 0.7, "required_checks": ["completeness", "clarity"]},
            "plan": {"min_score": 0.75, "required_checks": ["feasibility", "alignment"]},
            "design": {"min_score": 0.8, "required_checks": ["consistency", "scalability"]},
            "build": {"min_score": 0.85, "required_checks": ["functionality", "maintainability"]},
            "validate": {"min_score": 0.9, "required_checks": ["coverage", "reliability"]},
            "launch": {"min_score": 0.95, "required_checks": ["stability", "performance"]}
        }

        thresholds = quality_thresholds.get(phase, {"min_score": 0.8, "required_checks": []})

        # Analyze quality artifacts
        quality_score = 0.0
        issues = []
        recommendations = []

        if quality_artifacts:
            # Calculate average quality score from artifacts
            scores = []
            for artifact in quality_artifacts:
                score = artifact.content.get("quality_score", 0.8)  # Default to 0.8 if not specified
                scores.append(score)

            quality_score = sum(scores) / len(scores) if scores else 0.8

            # Check for quality issues
            for artifact in quality_artifacts:
                content_issues = artifact.content.get("issues", [])
                issues.extend(content_issues)

                content_recommendations = artifact.content.get("recommendations", [])
                recommendations.extend(content_recommendations)
        else:
            issues.append("No quality artifacts found")
            recommendations.append("Generate quality assessment for this phase")

        passed = quality_score >= thresholds["min_score"] and len(issues) == 0

        return {
            "passed": passed,
            "quality_score": quality_score,
            "threshold": thresholds["min_score"],
            "issues": issues,
            "recommendations": recommendations,
            "artifacts_analyzed": len(quality_artifacts)
        }

    async def _validate_phase_risks(self, project_id: UUID, phase: str) -> Dict[str, Any]:
        """Validate risk assessment for a phase."""
        # Get risk-related artifacts
        risk_artifacts = []
        all_artifacts = self.context_store.get_artifacts_by_project(project_id)

        for artifact in all_artifacts:
            if "risk" in artifact.artifact_type.lower() or "risk" in str(artifact.content).lower():
                risk_artifacts.append(artifact)

        # Analyze risks
        high_risks = []
        mitigations = []
        acceptable = True

        for artifact in risk_artifacts:
            risks = artifact.content.get("risks", [])
            for risk in risks:
                severity = risk.get("severity", "low")
                if severity in ["high", "critical"]:
                    high_risks.append(risk.get("description", "High severity risk identified"))
                    acceptable = False

                mitigation = risk.get("mitigation", "")
                if mitigation:
                    mitigations.append(mitigation)

        if not risk_artifacts:
            acceptable = False
            high_risks.append("No risk assessment found")
            mitigations.append("Conduct comprehensive risk assessment")

        return {
            "acceptable": acceptable,
            "high_risks": high_risks,
            "mitigations": mitigations,
            "artifacts_analyzed": len(risk_artifacts)
        }

    async def process_phase_gate_response(
        self,
        hitl_request_id: UUID,
        action: str,
        comment: str,
        user_id: Optional[str] = None,
        amendments: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Process phase gate HITL response with phase transition logic.

        Args:
            hitl_request_id: HITL request identifier
            action: Response action (approve, reject, amend)
            comment: User comment
            user_id: User identifier
            amendments: Amendment data if action is amend

        Returns:
            Processing results with phase transition status
        """
        # Get HITL request
        hitl_request = self.db.query(HitlRequestDB).filter(HitlRequestDB.id == hitl_request_id).first()
        if not hitl_request:
            raise ValueError(f"HITL request {hitl_request_id} not found")

        # Extract phase gate context
        phase_gate_context = hitl_request.amended_content.get("phase_gate_context", {})
        phase = phase_gate_context.get("phase")
        gate_type = phase_gate_context.get("gate_type")

        # Process standard HITL response
        response_result = await self.process_hitl_response(
            hitl_request_id, HitlAction(action), comment=comment, user_id=user_id
        )

        # Add phase gate specific processing
        phase_transition_result = await self._process_phase_gate_transition(
            hitl_request, action, phase, gate_type, amendments
        )

        # Combine results
        result = {**response_result, **phase_transition_result}

        logger.info("Phase gate response processed",
                   hitl_request_id=str(hitl_request_id),
                   phase=phase,
                   gate_type=gate_type,
                   action=action,
                   phase_transition=phase_transition_result.get("phase_transitioned", False))

        return result

    async def _process_phase_gate_transition(
        self,
        hitl_request: HitlRequestDB,
        action: str,
        phase: str,
        gate_type: str,
        amendments: Optional[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Process phase transition based on gate response."""
        from app.services.orchestrator import OrchestratorService
        orchestrator = OrchestratorService(self.db)

        result = {
            "phase_transitioned": False,
            "phase": phase,
            "gate_type": gate_type,
            "transition_reason": "",
            "next_phase": None
        }

        if action == "approve":
            # Attempt phase transition
            if gate_type == "exit":
                transition_result = orchestrator.transition_to_next_phase(hitl_request.project_id)
                result.update({
                    "phase_transitioned": transition_result.get("transitioned", False),
                    "transition_reason": "Gate approved - phase transition initiated",
                    "next_phase": transition_result.get("to_phase")
                })
            else:
                result["transition_reason"] = f"{gate_type.title()} gate approved - phase can proceed"

        elif action == "reject":
            result["transition_reason"] = f"{gate_type.title()} gate rejected - phase blocked"

        elif action == "amend":
            result["transition_reason"] = f"{gate_type.title()} gate amendments required"
            # Store amendments for phase improvement
            if amendments:
                await self._store_phase_gate_amendments(hitl_request.project_id, phase, amendments)

        return result

    async def _store_phase_gate_amendments(
        self,
        project_id: UUID,
        phase: str,
        amendments: Dict[str, Any]
    ) -> None:
        """Store phase gate amendments for future reference."""
        amendment_artifact = self.context_store.create_artifact(
            project_id=project_id,
            source_agent="hitl_gate",
            artifact_type="phase_amendment",
            content={
                "phase": phase,
                "amendments": amendments,
                "created_at": datetime.now(timezone.utc).isoformat(),
                "status": "pending_implementation"
            }
        )

        logger.info("Phase gate amendments stored",
                   project_id=str(project_id),
                   phase=phase,
                   amendment_artifact_id=str(amendment_artifact.context_id))

    async def get_phase_gate_status(self, project_id: UUID) -> Dict[str, Any]:
        """Get comprehensive phase gate status for a project."""
        from app.services.orchestrator import OrchestratorService
        orchestrator = OrchestratorService(self.db)

        current_phase = orchestrator.get_current_phase(project_id)
        phase_progress = orchestrator.get_phase_progress(project_id)

        # Get pending phase gate HITL requests
        pending_gates = []
        hitl_requests = await self.get_pending_hitl_requests(project_id)

        for request in hitl_requests:
            if request.amended_content and "phase_gate_context" in request.amended_content:
                gate_context = request.amended_content["phase_gate_context"]
                pending_gates.append({
                    "request_id": str(request.request_id),
                    "phase": gate_context.get("phase"),
                    "gate_type": gate_context.get("gate_type"),
                    "created_at": request.created_at,
                    "expires_at": request.expires_at
                })

        return {
            "project_id": str(project_id),
            "current_phase": current_phase,
            "phase_progress": phase_progress,
            "pending_gates": pending_gates,
            "gate_blockers": len(pending_gates),
            "ready_for_next_phase": len(pending_gates) == 0
        }

    async def auto_create_phase_gates(
        self,
        project_id: UUID,
        phase: str,
        gate_type: str = "exit"
    ) -> Optional[HitlRequest]:
        """
        Automatically create phase gate HITL if requirements are met.

        Args:
            project_id: Project identifier
            phase: SDLC phase
            gate_type: Type of gate to create

        Returns:
            HITL request if gate created, None if requirements not met
        """
        # Validate requirements first
        validation = await self.validate_phase_gate_requirements(project_id, phase, gate_type)

        if not validation["ready_for_gate"]:
            logger.info("Phase gate requirements not met - skipping auto-creation",
                       project_id=str(project_id),
                       phase=phase,
                       gate_type=gate_type,
                       blocking_issues=validation["blocking_issues"])
            return None

        # Get deliverables for the gate
        deliverables = []
        if validation["validation_checks"]:
            for check in validation["validation_checks"]:
                if check["check"] == "deliverables" and "details" in check:
                    deliverables = check["details"].get("completed", [])

        # Create the phase gate HITL
        hitl_request = await self.create_phase_gate_hitl(
            project_id=project_id,
            phase=phase,
            gate_type=gate_type,
            deliverables=deliverables,
            quality_metrics=validation.get("quality_metrics"),
            risk_assessment=validation.get("risk_assessment")
        )

        logger.info("Auto-created phase gate HITL",
                   project_id=str(project_id),
                   phase=phase,
                   gate_type=gate_type,
                   hitl_request_id=str(hitl_request.request_id))

        return hitl_request
